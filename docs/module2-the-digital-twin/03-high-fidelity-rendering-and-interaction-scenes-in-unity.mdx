---
title: "3. High-Fidelity Rendering and Interaction Scenes in Unity"
sidebar_position: 3
chapter_type: "hands-on"
learning_goals:
  - "Understand why Unity complements Gazebo for robotics simulation"
  - "Learn to import robot models (URDF) into Unity"
  - "Create photorealistic scenes using Unity's rendering capabilities"
  - "Design interactive scenarios for human-robot interaction"
prerequisites:
  - "Completion of previous chapters on Gazebo"
  - "Basic familiarity with 3D graphics concepts"
  - "Unity Hub and Unity Editor installed"
key_takeaways:
  - "Unity excels at photorealistic rendering and human interaction scenarios"
  - "Gazebo handles physics accuracy; Unity handles visual fidelity"
  - "URDF importers bridge ROS robotics with Unity game engine"
  - "Unity's HDRP enables realistic lighting and materials for sim-to-real"
---

# High-Fidelity Rendering and Interaction Scenes in Unity




## Introduction to Unity for Robotics

While Gazebo excels at physics simulation and ROS integration, **Unity** brings a different strength: photorealistic rendering and rich interaction scenarios. Unity is a professional game engine used in AAA games, architectural visualization, and increasingly, robotics research.

<LearningGoals>
- Understand why Unity complements Gazebo for robotics simulation
- Learn to import robot models (URDF) into Unity
- Create photorealistic scenes using Unity's rendering capabilities
- Design interactive scenarios for human-robot interaction
</LearningGoals>

<Prerequisites>
- Completion of previous chapters on Gazebo
- Basic familiarity with 3D graphics concepts
- Unity Hub and Unity Editor installed
</Prerequisites>

## Unity vs. Gazebo: Complementary Tools

The choice between Unity and Gazebo isn't binary—they serve different purposes:

| Aspect | Gazebo | Unity |
|--------|--------|-------|
| **Primary Purpose** | Physics simulation | Rendering & interactivity |
| **Physics Accuracy** | High (ODE, Bullet, DART) | Moderate (PhysX, limited realism) |
| **Visual Quality** | Functional | Photorealistic |
| **ROS Integration** | Native (designed for ROS) | Via plugins (Unity Robotics Hub) |
| **Performance** | CPU-bound physics | GPU-accelerated rendering |
| **Use Case** | Algorithm testing, control | Visualization, HRI, training data |
| **Learning Curve** | Moderate (roboticists) | Moderate (game developers) |

### When to Use Unity

1. **Human-Robot Interaction (HRI)**: Simulating realistic home environments, offices, or public spaces
2. **Synthetic Data Generation**: Creating labeled images for computer vision training
3. **Visualization**: Impressive demos for stakeholders or publications
4. **Edge Case Testing**: Simulating rare visual conditions (fog, reflections, shadows)
5. **Multi-modal Learning**: Training vision-language-action models in rich environments

### When to Use Gazebo

1. **Control Algorithm Development**: Testing PID controllers, motion planners, SLAM
2. **Physics-Critical Tasks**: Manipulation, contact-rich tasks, walking stability
3. **ROS-Native Workflows**: Direct integration with ROS 2 nodes and topics
4. **Lightweight Simulation**: Running on servers without GPUs

### The Hybrid Approach

Many teams use **both**:
- **Gazebo**: Develop and test control algorithms with accurate physics
- **Unity**: Generate training data, visualize results, test perception in realistic scenes
- **Co-simulation**: Run Gazebo for physics and Unity for rendering simultaneously

## Unity Robotics Hub

Unity provides the **Unity Robotics Hub**, a suite of tools for robotics:

- **URDF Importer**: Converts ROS URDF files to Unity GameObjects
- **ROS-TCP-Connector**: Bidirectional communication between Unity and ROS 2
- **Perception Package**: Tools for synthetic data generation and labeling
- **Robot Visualizer**: Real-time robot state visualization from ROS topics

### Installing Unity Robotics Hub

1. **Install Unity Hub** (if not already installed):
   - Download from [unity.com](https://unity.com/)
   - Install Unity Editor 2021.3 LTS or newer

2. **Create a new Unity project**:
   - Open Unity Hub
   - Click "New Project"
   - Select "3D (URP)" or "3D (HDRP)" template
   - Name it `HumanoidRoboticsSimulation`

3. **Install Unity Robotics Hub packages**:
   - In Unity Editor: Window → Package Manager
   - Click "+" → Add package from git URL
   - Add:
     - `https://github.com/Unity-Technologies/ROS-TCP-Connector.git?path=/com.unity.robotics.ros-tcp-connector`
     - `https://github.com/Unity-Technologies/URDF-Importer.git?path=/com.unity.robotics.urdf-importer`

## Importing a Robot into Unity

Let's import a robot URDF model into Unity.

### Step 1: Prepare Your URDF

Ensure your URDF file:
- Has valid mesh paths (STL or DAE files)
- Uses relative paths for meshes
- Includes visual and collision geometry

Example URDF structure:
```
my_robot/
├── urdf/
│   └── robot.urdf
└── meshes/
    ├── base_link.stl
    ├── arm_link.stl
    └── gripper.stl
```

### Step 2: Import URDF in Unity

1. **Copy URDF folder to Unity project**:
   - Place `my_robot/` folder in `Assets/` directory

2. **Import URDF**:
   - In Unity Editor: Robotics → Import URDF
   - Select `robot.urdf`
   - Configure import settings:
     - **Mesh Decomposer**: vHACD (for complex meshes)
     - **Axis Type**: Y-axis (Unity's up direction)
     - **Mesh Scale Factor**: 1.0

3. **Verify Import**:
   - Robot appears in Scene view
   - Check Hierarchy for all links
   - Verify joints have ArticulationBody components

### Step 3: Configure Physics

Unity uses **ArticulationBody** for robot joints (like ROS joints):

```csharp
// Access ArticulationBody in C#
ArticulationBody joint = GetComponent<ArticulationBody>();

// Set joint target position (for prismatic or revolute joints)
joint.xDrive = new ArticulationDrive
{
    target = 45.0f,  // Target angle in degrees
    stiffness = 10000,
    damping = 100,
    forceLimit = 1000
};
```

## Photorealistic Rendering with HDRP

Unity's **High Definition Render Pipeline (HDRP)** enables cinematic-quality graphics.

### Setting Up HDRP

1. **Convert project to HDRP** (if not already):
   - Window → Rendering → Render Pipeline Converter
   - Select "Built-in to HDRP"
   - Click "Convert Assets"

2. **Configure lighting**:
   - Add **Directional Light** (sun)
   - Add **HDRI Sky** for environment lighting
   - Enable **Screen Space Reflections** and **Ambient Occlusion**

### Key HDRP Features for Robotics

**1. Physically Based Materials**

Use realistic materials for robot and environment:

```csharp
// Example: Metallic robot parts
Material metal = new Material(Shader.Find("HDRP/Lit"));
metal.SetFloat("_Metallic", 0.9f);
metal.SetFloat("_Smoothness", 0.8f);
metal.SetColor("_BaseColor", Color.gray);
```

**2. Volumetric Lighting**

Simulate fog, haze, or indoor lighting scattering:

- Add **Local Volumetric Fog** to scene
- Adjust density and scattering

**3. Ray Tracing (Optional)**

For cutting-edge realism:
- Requires RTX GPU
- Enable in HDRP settings
- Provides accurate reflections, shadows, and global illumination

### Creating a Home Environment

Let's build a realistic home scene for a humanoid robot assistant:

1. **Import Assets**:
   - Unity Asset Store → Search "Home Interior"
   - Import free/paid furniture packs

2. **Construct Scene**:
   - Add floor plane (scale: 10×10)
   - Add walls using cubes
   - Place furniture (couch, table, chairs)
   - Add kitchen appliances

3. **Lighting Setup**:
   - **Directional Light** (window sunlight)
   - **Point Lights** (ceiling lamps)
   - **Emission Materials** (light fixtures)

4. **Post-Processing**:
   - Add **Volume** component
   - Enable **Bloom** (soft glow)
   - Enable **Depth of Field** (camera focus)
   - Add **Color Grading** (warm indoor tones)

## Creating Interactive Scenes

Unity's strength is interactivity. Let's create scenarios where robots interact with objects and humans.

### Scenario 1: Object Manipulation

Create a table with graspable objects:

```csharp
// Make object graspable
public class GraspableObject : MonoBehaviour
{
    private Rigidbody rb;
    private bool isGrasped = false;
    private Transform gripper;

    void Start()
    {
        rb = GetComponent<Rigidbody>();
    }

    public void Grasp(Transform gripperTransform)
    {
        isGrasped = true;
        gripper = gripperTransform;
        rb.isKinematic = true; // Disable physics while grasped
    }

    public void Release()
    {
        isGrasped = false;
        rb.isKinematic = false;
    }

    void Update()
    {
        if (isGrasped)
        {
            // Object follows gripper
            transform.position = gripper.position;
            transform.rotation = gripper.rotation;
        }
    }
}
```

### Scenario 2: Human Avatar Interaction

Use Unity's Animation system to create human avatars:

1. **Import Humanoid Character**:
   - Asset Store → "Humanoid Characters"
   - Import model with animations

2. **Set Up Animation Controller**:
   - Create Animator Controller
   - Add animations: Idle, Walking, Sitting, Waving

3. **Script Interaction**:
```csharp
public class HumanAvatar : MonoBehaviour
{
    private Animator animator;

    void Start()
    {
        animator = GetComponent<Animator>();
    }

    public void WaveAtRobot()
    {
        animator.SetTrigger("Wave");
    }

    public void SitDown()
    {
        animator.SetBool("IsSitting", true);
    }
}
```

### Scenario 3: Voice-Controlled Robot

Integrate speech recognition for natural interaction:

```csharp
using UnityEngine;

public class VoiceController : MonoBehaviour
{
    // This would integrate with Unity's speech recognition or external APIs
    public void OnVoiceCommand(string command)
    {
        switch (command.ToLower())
        {
            case "come here":
                MoveRobotToUser();
                break;
            case "pick up cup":
                GraspObject("Cup");
                break;
            case "sit down":
                ExecuteSittingMotion();
                break;
        }
    }

    void MoveRobotToUser()
    {
        // Navigation logic
        Debug.Log("Robot moving to user");
    }

    void GraspObject(string objectName)
    {
        GameObject obj = GameObject.Find(objectName);
        if (obj != null)
        {
            obj.GetComponent<GraspableObject>()?.Grasp(transform);
        }
    }

    void ExecuteSittingMotion()
    {
        // Play sitting animation
        GetComponent<Animator>().SetTrigger("Sit");
    }
}
```

## Unity-ROS Communication

To integrate Unity with your ROS 2 stack, use the **ROS-TCP-Connector**.

### Setup ROS-TCP Endpoint

1. **Install ROS package** (on Linux/ROS side):
```bash
sudo apt-get install ros-humble-ros-tcp-endpoint
```

2. **Launch endpoint**:
```bash
ros2 run ros_tcp_endpoint default_server_endpoint --ros-args -p ROS_IP:=0.0.0.0
```

3. **Configure Unity**:
   - Robotics → ROS Settings
   - Set ROS IP Address: `127.0.0.1` (or your ROS machine IP)
   - Set ROS Port: `10000`

### Example: Visualizing ROS Joint States

```csharp
using Unity.Robotics.ROSTCPConnector;
using RosMessageTypes.Sensor;

public class JointStateSubscriber : MonoBehaviour
{
    void Start()
    {
        ROSConnection.GetOrCreateInstance().Subscribe<JointStateMsg>(
            "/joint_states",
            UpdateJointPositions
        );
    }

    void UpdateJointPositions(JointStateMsg jointStateMsg)
    {
        for (int i = 0; i < jointStateMsg.name.Length; i++)
        {
            string jointName = jointStateMsg.name[i];
            float position = (float)jointStateMsg.position[i];

            // Find corresponding ArticulationBody and update
            ArticulationBody joint = FindJointByName(jointName);
            if (joint != null)
            {
                joint.xDrive = new ArticulationDrive
                {
                    target = position * Mathf.Rad2Deg
                };
            }
        }
    }

    ArticulationBody FindJointByName(string name)
    {
        // Implementation to find joint in robot hierarchy
        return GameObject.Find(name)?.GetComponent<ArticulationBody>();
    }
}
```

<KeyTakeaways>
- Unity excels at photorealistic rendering and human interaction scenarios
- Gazebo handles physics accuracy; Unity handles visual fidelity
- URDF importers bridge ROS robotics with Unity game engine
- Unity's HDRP enables realistic lighting and materials for sim-to-real
- Unity Robotics Hub provides ROS integration via TCP connector
- Interactive scenarios in Unity enhance HRI research and testing
</KeyTakeaways>


## Next Steps

In the next chapter, we'll dive deep into advanced sensor simulation: LiDAR, depth cameras, and IMUs. You'll learn to simulate sensor noise and generate synthetic training data.

<ExerciseBlock
  question="Import a simple robot URDF into Unity, place it in a realistic indoor scene, and configure HDRP lighting to create a photorealistic rendering. Bonus: Set up ROS-TCP-Connector to visualize live joint states from a ROS 2 topic."
  hints={[
    { title: "Hint 1", content: "Start with Unity's HDRP template and use the URDF Importer from Unity Robotics Hub." },
    { title: "Hint 2", content: "Use free assets from the Unity Asset Store for indoor furniture (search 'home interior' or 'apartment')." },
    { title: "Hint 3", content: "For lighting, add a Directional Light for sunlight and Point Lights for indoor lamps. Enable Global Illumination." }
  ]}
  solution={
    <div>
      <p><strong>Sample Solution:</strong></p>
      <p><strong>Step 1: Create HDRP Project</strong></p>
      <ol>
        <li>Unity Hub → New Project → 3D (HDRP)</li>
        <li>Name: "HumanoidRobotHRI"</li>
      </ol>
      <p><strong>Step 2: Install Unity Robotics Hub</strong></p>
      <ol>
        <li>Window → Package Manager</li>
        <li>Add packages from git URL:
          <ul>
            <li><code>https://github.com/Unity-Technologies/ROS-TCP-Connector.git?path=/com.unity.robotics.ros-tcp-connector</code></li>
            <li><code>https://github.com/Unity-Technologies/URDF-Importer.git?path=/com.unity.robotics.urdf-importer</code></li>
          </ul>
        </li>
      </ol>
      <p><strong>Step 3: Import Robot URDF</strong></p>
      <ol>
        <li>Copy your robot URDF folder to <code>Assets/Robots/</code></li>
        <li>Robotics → Import URDF → Select robot.urdf</li>
        <li>Import Settings: Y-axis up, vHACD decomposer</li>
      </ol>
      <p><strong>Step 4: Build Indoor Scene</strong></p>
      <ol>
        <li>Asset Store → Download "Simple Interior" (free)</li>
        <li>Import and place furniture in scene</li>
        <li>Position robot in the room</li>
      </ol>
      <p><strong>Step 5: Configure HDRP Lighting</strong></p>
      <pre>{`// Scene Setup
1. GameObject → Light → Directional Light
   - Intensity: 50000 lux
   - Color: Warm white (temperature: 5500K)
   - Angle: 45° to simulate window light

2. GameObject → Light → Point Light (×3)
   - Position above furniture
   - Intensity: 1000 lumens
   - Color: Warm white (temperature: 3000K)

3. GameObject → Volume → Global Volume
   - Add Override: Exposure
   - Add Override: Bloom (intensity: 0.2)
   - Add Override: Ambient Occlusion`}</pre>
      <p><strong>Step 6: ROS Integration (Bonus)</strong></p>
      <pre>{`// In ROS terminal:
ros2 run ros_tcp_endpoint default_server_endpoint

// In Unity:
1. Robotics → ROS Settings
   - ROS IP: 127.0.0.1
   - Port: 10000
2. Attach JointStateSubscriber.cs to robot
3. Press Play - robot should mirror ROS joint states`}</pre>
      <p><strong>Result:</strong> You should see a photorealistic indoor scene with a robot that responds to lighting realistically, showing proper shadows, reflections, and material properties.</p>
    </div>
  }
/>
